<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        // 원하는 값을 직접적으로 입력 :리터럴 
        // 리터럴로 넣었을 때는 한꺼번에 값이 들엉감 
        let puppy = {
            //속성
            name : "초코",
            //메서드
            eat : function() {
                document.write("<p>밥을 먹습니다</p>")
            },
            run : () => {
                document.write("<p>달립니다</p>");
            }
        }

        let person = {
            name : "홍길동",
            address : "부산",
            intro : function () { return `${person.name}입니다. ${this.address}에 거주중입니다`}
        }

        let myCookie = {
            // 메소드 값이 아닌 객체를 가져오고 싶을 때는 
            // 객체의 이름을 통해서 가져옴 (객체 안의 속성들에 접근)
            // 객체 or this를 통해 현재 객체의 shape를 가져옴 
            shape : "원",
            flavor : "초코",
            intro : function () { 
                return `${this.shape}모양의 ${this.flavor}맛입니다`
            }
        }

        // new object()
        // object를 사용할 경우 
        // 동일한 값의 형태나 메소드를 가질 경우 계속해서 작성해야 함 
        let tree = new Object(); // 만들고자 하는 객체 선언 
        tree.kind = "은행나무"; // 괄호 안에 존재하는 객체
        tree.light = function () { // light라는 함수를 가 tree 안에 들어감
            document.write(`<p>${tree.kind}가 광합성을 합니다</p>`)
        }

        let myBook = new Object();
        myBook.title = "어린왕자"
        myBook.price = 6000;
        myBook.intro = function() {
            document.write(`<p>${myBook.title}입니다 ${myBook.price}입니다</p>`)
        }
        myBook.discount = function() {
            myBook.price *= 0.9 
        }

        let myWallet = new Object();
        myWallet.owner = "홍길동";
        myWallet.money = 10000;
        myWallet.show = function() {
            return `현재 ${myWallet.money} 남았습니다`
        }
        myWallet.buy = function(pay) {
            if( myWallet.money >= pay) {
                myWallet.money -= pay;
            }else {
                return "물건을 살수 없다."
            }
        }
        myWallet.input = function (money) {
            myWallet.money += money;
        }

        // 동일한 값을 가지고 있을 때, 생성자 함수를 통해서 작성 
        // 대문자로 작성해 생성자 함수를 작성했다는 것을 표시
        function Dog(name, age) {
            this.name = name;
            this.age = age;
            this.print = function () {
                document.write(`<p>${this.name}입니다</p>`)
            }
        }
        // 값을 가진 객체 생성 new
        let myPuppy = new Dog("백구", 1);

        // 생성자 함수(객체를 만드는 틀)
        // 메소드는 각각의 객체마다 따로 할당할 수 있음
        function Student (name, score) {
            this.name = name;
            this.score = score;
            this.study = function( ) {
                this.score += 10;
            }
            this.showScore = function () {
                return this.score;
            }
        }
        // 객체생성
        // 생성자 함수 작성시, 객체를 생성해줘야지만 쓸 수 있는 객체가 됨
        let myStudent = new Student("홍길동", 70);
        let yourStudent = new Student("성춘향", 80);

        function BusCard(money) {
            this.money = money;
            this.charge = function(money) {
                this.money += money;
            }
            this.takeBus = function() {
                if(this.money>= 1500) {
                    this.money == 1500;
                }
                else {
                    return "잔액이 부족합니다";
                }
            }
            this.showMoney = function () {
                return this.money;
            }
        }

        let myBusCard = new BusCard(1500);
        let yourBusCard = new BusCard(1000);

        // 객체생성실습3
        function Message(name, content, time) {
            this.name= name ;
            this.content = content;
            this.time =time ;
            this.modifyMessage = function(message) {
                this.content = message;
            }
            this.showMessage = function(){
            return `${this.name}님 께서 ${this.content}`   
            }
        }
        // this를 통해서 값을 고정 ,자료형 주의해 작성 
        // 위치에 따라서 this값이 변하기 때문(현재 속한 함수의 자기자신)
        let myMessage = new Message ("우리", "반갑습니다", "0224");
        let youtMessage = new Message("둘리", "안녕하세요", "0313")

        // delete myMessage.content(name);
        // console.log(myMessage);

        // 콘솔 : for in 루프 > 속성 이름으로 접근할 수 있음
        // for (let x in puppy) {
        // console.log(x+":"+puppy[x])
        // }
        
        //  name:초코
        //  eat:function() {
        //  document.write("<p>밥을 먹습니다</p>")
        //   }
        //  run:() => {
        //  document.write("<p>달립니다</p>");
        //   }

        let memo = {
            title : "오늘 할일",
            todo : {
                morning : ["청소", "준비"],
                afternoon : ["수업"],
                evening : ["정리", "독서"]
            }
        };

        // 객체속성으로 가지는 객체 실습
        let myMovie = {
            title : "헤어질 결심",
            time :"136",
            rate : 8.84,
            coment : {
                id : "movieMaster",
                content : "Good"
            }
        }


        // 동물병원 진료차트
        // 진료차트의 속성 설정
        function AnimalChart (name,kind,age) {
            this.name = name;
            this.kind = kind; 
            this.age = age;
            this.sickness = "";
            this.condition = "";
            this.receive = function (sickness, condition) {
                this.sickness = sickness;
                this.condition = condition;
            }
            this.confirm = function () {

                let s = ""
                for (let x in this) {

                    // 자료형인지 확인하기 위해 typeof 사용
                    console.log(typeof this[x])
                    
                    // 함수부분은 제외하기 위함 
                    if(typeof this[x] == "function"){
                        continue;
                    }
                        s+= x + ":" +this[x]+ "\n";
                }
                return s ;
                // let s = this.name + this.kind +this.age + this.sickness +this.condition
                // return s;
            }
        }

        // 속성이 여러개일 때는 for문을 통해서 접근
        let first = new AnimalChart("김지현", "고양이", 1);
        first.receive("감기", "매우나쁨");
        first.confirm(); // 입력한 모든 속성 이름들이 출력

        


    </script>
</body>
</html>