<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <h1>FetchAPI를 이용한 비동기 자바스크립트 - Ajax</h1>
    <!-- 버튼을 눌럿을 때, json의 object에 name과 adress출력 -->
    <button id="fetch-btn">fetchAPI를 사용한 버튼</button>
    <p id="fetch-print"></p>
    <script>
        // fetch는 promise 객체로 반환, 그 값을 then으로 받아서 쓸 수 있음 
        console.log(fetch(`./data.text`))
        // then을 통해서 사용할 때 안에 화살표함수를 사용해서 꺼내씀  
        fetch(`./data.text`).then(presponse => {
            //fetch와 then을 통해서 값을 받아오면 promise 객체 생성(return값)
            // fetch라는 메소드가 비동기로 움직이기 때문
            // promise 객체의 특징 
            // 같은 promise.response의 text메소드를 사용할 경우
            // 두번째 호출하는 경우, reject라 나와있고, 이미 stream이 이미 읽혔다고 이야기함
            // promise 객체가 한번이라도 호출이 된다면 안에 있는 내용을 다 쓰고 비어있는 상태임 
            //console.log(presponse);
            // text()의 결과값이 promise 객체
            // then으로 풀어서 사용하기 위해 return으로 전달
            return presponse.text();
        }).then(ptext => console.log(ptext))


        console.log(fetch(`./data.json`))
        // JSON()을 통해 객체로 만들어 출력 
        fetch(`./data.json`).then(rep => {
            return rep.json();
        }).then(jsonText => {
            console.log(jsonText)
        })

        // fetchAPI를 통해서 data.json 콘솔에 출력
        fetch(`./data.json`,{method:"GET"})
        .then(rep => rep.json()) // rep 객체의 json() 결과값을 return 으로 보냄 
        .then(jsonText => console.log(jsonText))
        

        // 원하는 정보를 가져와서 fetch api를 통해 객체 출력
        const fetchBtn = document.querySelector("#fetch-btn");
        fetchBtn.addEventListener("click", function(){
            fetch("./data.json")
            .then(response => response.json())
            .then(jsonData => {
                const PTag = document.querySelector("#fetch-print");
                PTag.innerHTML = `${jsonData.object.name}<br>${jsonData.object.adress}`
            })
        })


        // Async /await로 비동기 접근 
        // async : 비동기로 사용할 함수 앞에 붙여주어 그 안의 내용도 비동기로 처리 
        // > fetchAPI를 async붙은 함수에 넣어줘서 처리 - then 대신에 사용 
        // await 메소드 또는 함수 앞에 붙여주면 값이 바뀔 때 까지 기다린다.
        // > promise 객체를 기다리는 키워드 
        
        async function doFetch() {
            const response = await fetch('https://busan-food.openapi.redtable.global/api/menu-dscrn/korean?serviceKey=3cOsoxEnSZYVeTrfKrARQcYYonhykJwpZEurgWtYALHVUijbNn2a5tu7p5V7MIcw');
            console.log(response);
            if(!response.ok) {
                console.log("연결이 되지 않았습니다 잠시 후 다시 실행해주세요");
                return 0;
            }
            // 안에 있는 프로미스 객체를 await을 통해 들고옴 
            const data = await response.json();
            console.log(data);
            console.log(data.body[0].MENU_NM)

            const pTag = document.createElement("p");
       //     pTag.innerHTML = data.body[0].MENU_NM;
            document.querySelector("body").append(pTag)

            // table 태그 만들어서 
            // 인덱스 0~99 까지의 메뉴이름을 td에 출력하기
            const menuTable = document.querySelector("table");
                for(let i=0; i<100; i++) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                    <td>${data.body[i].RSTR_NM}</td> 
                    <td>${data.body[i].MENU_NM}</td>`
                    menuTable.append(tr);
                }
                document.querySelector("body").append(menuTable);
        }
        doFetch()
        
            // RSTR_NM을 이용해 식당 이름도 출력

    </script>
</body>
</html>